---
title: "Auditory Mountain"
output:
  html_document:
    toc: yes
    css: style.css
date: "`r format(Sys.time(), '%B %d %Y')`"
---

<!--pandoc
t: html
s:
mathjax:
o: analysis.html
-->


```{r initialization, echo=FALSE, message=FALSE, warning=FALSE}
library(plyr)
library(rjson)
library(ggplot2)
library(RColorBrewer)
library(devtools)
library(reshape2)
library(scales)
library(dplyr)
library(rCharts)
library(zoo)
library(grid)
library(knitr)
library(pander)
library(kfigr)
library(XLConnect)
```

```{r global_options, include=FALSE}
knitr::opts_chunk$set(fig.path='figures/')
knitr::opts_chunk$set(comment = NA, results = "asis", comment = NA, tidy = F)
options("scipen"=100, "digits"=2)
opts_chunk$set(dev = 'svg')
opts_chunk$set(fig.cap='')
```

```{r preProc, include=FALSE, cache=FALSE}
# Pre processing of the data from the first design
source("R/preProcFirstDesign.R")
```

```{r thresholds, include=F, echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE}
# Check if there are frequency threshold data
if ('deltaF' %in% names(data)) {
  source("R/threshold.R")
}
```

```{r mountain, include=F, echo=FALSE, message=FALSE, warning=FALSE}
# Check if there is any mountain trial
if ('targetTone' %in% names(data)) {
  # Check if there is any yAxis trial
  if ('yAxis' %in% data$condition) {
    source("R/yAxis.R")
  }

  # Check if there is any lines trial
  if ('lines' %in% data$condition) {
    source("R/lines.R")
  }
  
  # Check if there is any circles trial
  if ('circles' %in% data$condition) {
    source("R/circles.R")
  }
}
```


```{r stats, include=F, echo=FALSE, message=FALSE, warning=FALSE}
# Load longitudinal analysis script (five days testing)
source("R/stats.R")
```

```{r plots, include=F, echo=FALSE, message=FALSE, warning=FALSE}

source("R/plots.R")

```

# Individual analyses

## Frequency threshold task

The frequency thresholds are calculated from an adaptive procedure where deltaF is decreased when a wrong answer is provided and increased for a right answer.

### Detection and identification deltaF

The evolution of the delta F values across trials for the detection and identification tasks is ploted bellow:

```{r plotDeltaF, echo=FALSE, message=FALSE, warning=FALSE, fig.height=length(levels(factor(raw.data$name)))*1.2, anchor="figure"}

plotDeltaF

```

 on the figure `r figr('plotDeltaF')`
 
### Thresholds

#### Each participant among sessions

The thresholds are calculated from the DeltaF values corresponding to the last 10 reversals. The procedure was repeated two times before training (sessions 1 and 2) and two times after (sessions 3 and 4). The figure bellow shows these thresholds across sessions for the detection and identification conditions:    

```{r plotThresholds, echo=FALSE, message=FALSE, warning=FALSE, fig.height=length(levels(factor(raw.data$name)))*1.1}

plotThresholds

```

```{r plotThresholdsOneLog, echo=FALSE, message=FALSE, warning=FALSE}

plotThresholdsOneLog

```

#### Each participant among sessions in percent of the first session

```{r plotThresholdsPercent, echo=FALSE, message=FALSE, warning=FALSE, fig.height=length(levels(factor(raw.data$name)))*1.1}

plotThresholdsPercent

```

### Detection threshold in function of identification threshold

#### Mean among session

```{r plotDetByIdAll, echo=FALSE, message=FALSE, warning=FALSE}

plotDetByIdAll

```

#### For each session

```{r plotDetById, echo=FALSE, message=FALSE, warning=FALSE}

plotDetById

```

#### Pre vs. post tests

The threshold scores are the means of the four sessions (two pre-test and two post-test)

```{r plotDetByIdPrepost, echo=FALSE, message=FALSE, warning=FALSE}

plotDetByIdPrepost

```

#### First vs. second tests

```{r plotDetByIdPrepre, echo=FALSE, message=FALSE, warning=FALSE}

plotDetByIdPrepre

```

## Auditory mountain task

Here are the plots of scores, accuracy and duration in function of trials. The accuracy is the difference between the choosen tone and the highest tone. The duration is the length in seconds of each trial from the begining of the sound to the answer. The score is a mixed value calculated from accuracy and duration according to this equation:

$$ (\frac{1}{(\frac{duration}{100}+1)^2} + 1) \times 600 \times (\frac{accuracy}{100})^2 $$

***

Thus, the time score is a multiplier between 1 for a very long trial and 2 for a very short one (few seconds). Thus, the accuracy score can be doubled with speed. 

The accuracy score is 600 maximum (the idea was to make a score in order to have the pleasure to cross 1000 points when the performance is good). For accuracy and time, the power function is used to provide the maximum of points near the perfect score and have a lot of difference when it is harder.

UPDATE:

The equation used from va01 (20/07/15) was modified to have a more steeper curve and invite people to be more accurate and avoid the strategy to make a lot of trial quickly and win a lot of points:

$$ (\frac{1}{(\frac{duration}{100}+1)^2} + 1) \times 600 \times (\frac{accuracy}{100})^6 $$

### Participant's scores

```{r plotScores, echo=FALSE, message=FALSE, warning=FALSE, fig.height=length(levels(factor(raw.data$name)))*1.1}

plotScores

```

### Accuracy of trials

```{r plotAcc, echo=FALSE, message=FALSE, warning=FALSE, fig.height=length(levels(factor(raw.data$name)))*1.1}

plotAcc

```

```{r plotAccOne, echo=FALSE, message=FALSE, warning=FALSE}

plotAccOne

```

### Durations of trials

```{r plotDur, echo=FALSE, message=FALSE, warning=FALSE, fig.height=length(levels(factor(raw.data$name)))*1.1}

plotDur

```

### Path coordinates

```{r plotPathCoord, echo=FALSE, message=FALSE, warning=FALSE, fig.height=25}

plotPathCoord

```

### Number of target crossings

The number of target crossing in the auditory mountain is the number of time the participant cross the target.

```{r plotCrossNum, echo=FALSE, message=FALSE, warning=FALSE, fig.height=15}

plotCrossNum

```

### Accuracy in function of duration for each trial

The variability of the results is not associated with duration. Each point is a trial.

```{r plotAccByDur, echo=FALSE, message=FALSE, warning=FALSE}

plotAccByDur

```

### Path length in function of duration for each trial

A correlation seems to exists between the length of the displacement on the screen and the duration of the trial

```{r plotLengthByDur, echo=FALSE, message=FALSE, warning=FALSE}

plotLengthByDur

```

### Accuracy in function of frequency of the target tone

The frequencies used in the mountain task are randomly taken from 400 Hz to 2400 Hz.

```{r plotAccByFreq, echo=FALSE, message=FALSE, warning=FALSE}

plotAccByFreq

```

### Comparison of frequency thresholds and accuracy

```{r plotAccThresh, echo=FALSE, message=FALSE, warning=FALSE, fig.height=length(levels(factor(raw.data$name)))*1.1}

plotAccThresh

```

```{r plotAccThreshMean, echo=FALSE, message=FALSE, warning=FALSE, fig.width=10, fig.height=7}

plotAccThreshMean

```


# Global analyses

## Frequency threshold task

```{r plotDeltaFMeans, echo=FALSE, message=FALSE, warning=FALSE}

# plotDeltaFMeans

```

### Mean of participant's thresholds

The mean thresholds are calculated from all participant's deltaF for each session (first and second in pre-test and third and fourth in post-test) and condition (detection and identification).


```{r plotMeanThresholds, echo=FALSE, message=FALSE, warning=FALSE}

plotMeanThresholdsPerc

```

### Mean of participant's thresholds (percent of the first session)

Thresholds are also calculated in percent of the first session deltaF.

```{r plotMeanThresholdsPercent, echo=FALSE, message=FALSE, warning=FALSE}

plotMeanThresholdsPercent

```

## Auditory mountain task

### Mean accuracy of trials

```{r plotAccMean, echo=FALSE, message=FALSE, warning=FALSE}

plotAccMean

```

### Correlation between mountain task accuracy and frequency thresholds

#### Identification frequency threhsold

```{r plotMountainByThreshId, echo=FALSE, message=FALSE, warning=FALSE}

plotMountainByThreshId

```

#### Detection frequency threhsold

```{r plotMountainByThreshDet, echo=FALSE, message=FALSE, warning=FALSE}

plotMountainByThreshDet

```

# Longitudinal analysis

Two participants (va01 and df22) who did the experiment were invited to do four other sessions (one a day) identical to the the first session (pre-test, training, post-test).

The protocol was also identical but the participants were told that the better one could win 10 euros more and that the total score would be calculated from all the training sessions and all the threshold measures.

Thus, the equation used to calculate the total score take into account the global scores to the mountain task of each session, the mean accuracy of all mountain task sessions and the results to each threshold tasks in this way:

$$ ScoreTotal + (1000 \times meanAccuracy) + \frac{20 000 000}{deltaFIdentification} + \frac{20 000 000}{deltaFDetection} $$

```{r competScore, include=FALSE, echo=FALSE, message=FALSE, warning=FALSE}

competScore_va01 <- round(sum(totalScoresLong$totalScore[totalScoresLong$name=="va01"]), 0) + 1000 * meanAccuracy$meanAcc[meanAccuracy$name=="va01"] + 20000000 / mean(thresholdsLongiAllLong$threshold[thresholdsLongiAllLong$name=="va01" & thresholdsLongiAllLong$condition=="identification"]) + 20000000 / mean(thresholdsLongiAllLong$threshold[thresholdsLongiAllLong$name=="va01" & thresholdsLongiAllLong$condition=="detection"])

competScore_df22 <- round(sum(totalScoresLong$totalScore[totalScoresLong$name=="df22"]), 0) + 1000 * meanAccuracy$meanAcc[meanAccuracy$name=="df22"] + 20000000 / mean(thresholdsLongiAllLong$threshold[thresholdsLongiAllLong$name=="df22" & thresholdsLongiAllLong$condition=="identification"]) + 20000000 / mean(thresholdsLongiAllLong$threshold[thresholdsLongiAllLong$name=="df22" & thresholdsLongiAllLong$condition=="detection"])

```

#### va01: {.lessEmphasized}

$$ `r sum(totalScoresLong$totalScore[totalScoresLong$name=="va01"])` + (1000 \times `r meanAccuracy$meanAcc[meanAccuracy$name=="va01"]`) + \frac{20 000 000}{`r mean(thresholdsLongiAllLong$threshold[thresholdsLongiAllLong$name=="va01" & thresholdsLongiAllLong$condition=="identification"])`} + \frac{20 000 000}{`r mean(thresholdsLongiAllLong$threshold[thresholdsLongiAllLong$name=="va01"
& thresholdsLongiAllLong$condition=="detection"])`} = `r competScore_va01` $$

#### df22: {.lessEmphasized}
$$ `r sum(totalScoresLong$totalScore[totalScoresLong$name=="df22"])` + (1000 \times `r meanAccuracy$meanAcc[meanAccuracy$name=="df22"]`) + \frac{20 000 000}{`r mean(thresholdsLongiAllLong$threshold[thresholdsLongiAllLong$name=="df22" & thresholdsLongiAllLong$condition=="identification"])`} + \frac{20 000 000}{`r mean(thresholdsLongiAllLong$threshold[thresholdsLongiAllLong$name=="df22" & thresholdsLongiAllLong$condition=="detection"])`} = `r competScore_df22` $$

## Frequency threshold task

The frequency threshold tests are done before and after each training session. The dotted vertical lines correspond to each first threshold task.

### All Subjects

```{r plotThresholdsLongi, echo=FALSE, message=FALSE, warning=FALSE}

plotThresholdsLongi

```

#### Mean

```{r plotThresholdsLongiMean, echo=FALSE, message=FALSE, warning=FALSE, fig.height=3, fig.width=6}

plotThresholdsLongiMeanPerc

```

### All Subjects percent

```{r plotThresholdsLongiPercent, echo=FALSE, message=FALSE, warning=FALSE}

plotThresholdsLongiPercent

```

### Mean percent

```{r plotMeanThresholdsLongiPercent, echo=FALSE, message=FALSE, warning=FALSE, fig.height=3}

plotMeanThresholdsLongiPercent

```

## Auditory mountain task

### Participant's scores

```{r plotScoresLongi, echo=FALSE, message=FALSE, warning=FALSE}

plotScoresLongi

```

### Accuracy of trials

```{r plotAccLongi, echo=FALSE, message=FALSE, warning=FALSE}

plotAccLongi

```

### Durations of trials

```{r plotDurLongi, echo=FALSE, message=FALSE, warning=FALSE}

plotDurLongi

```


# Auditory mountain as a frequency threshold measure

We calculated the efficiency of the auditory mountain task to give an estimate of the frequency threshold. It represents for each trial and each participant the difference between the whole mean of accuracy and the mean from trial 1 to the one presented. This difference is expressed in standard deviation (calculated with the whole trials of each participant). For instance, the value of the trial 21 for mn15 is around one standard deviation. This means that for this participant, the mean of the 21 first trials is away of the global mean by one standard deviation.

**Reference:** Schlauch, R. S., & Rose, R. M. (1990). Two‐, three‐, and four‐interval forced‐choice staircase procedures: Estimator bias and efficiency. *The Journal of the Acoustical Society of America*, 88(2), 732–740.


Here is the code used to compute these sd:

```{r code, message=FALSE, warning=FALSE}
# Create a vector with the cumulative mean of accuracy for each participant
yAxisEff <- yAxisEff %>%
  group_by(name) %>%
  mutate(
    roll=cummean(accuracy),
    mean=mean(accuracy),
    sd=sd(accuracy),
    # For each observation the difference between the cumulative mean
    # and the mean is calculated in sd
    se=abs(roll-mean)/sd)
```

and here is the form of the table created with the code above:

```{r plotSdDiff, echo=FALSE, message=FALSE, warning=FALSE}
set.caption('yAxisEff')
pander(head(yAxisEff))

plotSdDiff

```

The same thing can be done with the mean among participants for each trial.

```{r plotSdDiffMean, echo=FALSE, message=FALSE, warning=FALSE}

# plotSdDiffMean

```

# Statistical tests

Test of normality for each session and condition

```{r shap, echo=FALSE, message=FALSE, warning=FALSE, results='asis'}
# Session 1:
shap(data=thresholdsAllLong, cond="identification", sess=1, thresholdMax=100)

shap(data=thresholdsAllLong, cond="identification", sess=2, thresholdMax=100)
shap(data=thresholdsAllLong, cond="identification", sess=3, thresholdMax=100)
shap(data=thresholdsAllLong, cond="identification", sess=4, thresholdMax=100)
shap(data=thresholdsAllLong, cond="detection", sess=1, thresholdMax=100)
shap(data=thresholdsAllLong, cond="detection", sess=2, thresholdMax=100)
shap(data=thresholdsAllLong, cond="detection", sess=3, thresholdMax=100)
shap(data=thresholdsAllLong, cond="detection", sess=4, thresholdMax=100)

n1$show('inline', include_assets = TRUE)

```

# Session info

```{r session_info, include=TRUE, echo=TRUE, results='markup'}
devtools::session_info()
```
  